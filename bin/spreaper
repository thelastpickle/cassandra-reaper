#!/usr/bin/env python
# Copyright (c) 2014 Spotify AB
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
import argparse
import getpass
import logging
import requests
import sys
import urlparse

USER = getpass.getuser()
DEFAULT_CAUSE = "manual spreaper run"

log_level = logging.WARN
if "-v" in sys.argv or "--verbose" in sys.argv:
    log_level = logging.DEBUG
logging.basicConfig(level=log_level, format='%(asctime)s %(name)s %(levelname)s - %(message)s')

log = logging.getLogger("spreaper")
log.debug("logging initialized, the user running this: {0}".format(USER))


import json


def _global_arguments(parser):
    parser.add_argument("--reaper-host", default="localhost",
                        help="hostname of the Reaper service [localhost]")
    parser.add_argument("--reaper-port", default="8080",
                        help="port of the Reaper service [8080]")
    parser.add_argument("--reaper-use-ssl", default=False, action='store_true',
                        help="use https to call Reaper [False]")
    parser.add_argument("-v", "--verbose", help="increase output verbosity",
                        action="store_true")


def _triggering_arguments(parser):
    parser.add_argument("--owner", default=USER,
                        help="name of local user calling the Reaper [{0}]".format(USER))
    parser.add_argument("--cause", default=DEFAULT_CAUSE,
                        help="cause string used for logging and auditing "
                             "purposes [\"{0}\"]".format(DEFAULT_CAUSE))
    parser.add_argument("--keyspace", default=None,
                        help="the keyspace in the Cassandra cluster")
    parser.add_argument("--table", default=None,
                        help="the table within a keyspace in the Cassandra cluster")


def _parse_arguments(description, usage, extra_arguments=None):
    parser = argparse.ArgumentParser(description=description, usage=usage)
    _global_arguments(parser)
    if extra_arguments:
        extra_arguments(parser)
    return parser.parse_args(sys.argv[2:])


class ReaperCLI(object):
    '''Aim of this class is to separate CLI (argparse) specific stuff
    separate from the actual logic of calling Reaper.'''
    def __init__(self):
        parser = argparse.ArgumentParser(
            description="spreaper (Spotify Reaper) CLI tool is used to control "
                        "Reaper service through its REST API",
            usage="""spreaper <command> [<args>]
The available commands are:
    list-clusters  List registered Cassandra clusters in a Reaper
    register       Register a Cassandra cluster for repairs
    repair         Trigger a repair on a Cassandra cluster
    status-cluster Show status of a Cassandra cluster
    status-repair  Show status of a repair run
""")
        parser.add_argument('command', help='The subcommand to run')
        _global_arguments(parser)
        # parse_args defaults to [1:] for args, but you need to
        # exclude the rest of the args too, or validation will fail
        args = parser.parse_args(sys.argv[1:2])
        command = args.command.replace('-', '_')
        if not hasattr(self, command):
            print 'Unrecognized command: {0}'.format(args.command)
            parser.print_help()
            exit(1)
        # use dispatch pattern to invoke method with same)
        getattr(self, command)()

    def init_reaper(self, args):
        return ReaperCaller(args.reaper_host, args.reaper_port, args.reaper_use_ssl)

    def list_clusters(self):
        args = _parse_arguments('List all registered Cassandra clusters',
                                'spreaper list-clusters [<args>]')
        reaper = self.init_reaper(args)
        print "# listing all available clusters in the Reaper"
        cluster_names = reaper.call_list_clusters()
        if cluster_names:
            print "# found {0} clusters:".format(len(cluster_names))
            for cluster_name in cluster_names:
                print cluster_name
        else:
            print "no clusters found"

    def register(self):
        def arguments_for_register(parser):
            parser.add_argument("seed_host",
                                help="the seed host of the Cassandra cluster to be registered")
            parser.add_argument("--trigger-repair", default=False, action='store_true',
                                help="trigger repair immediately upon successful register [False]")
            _triggering_arguments(parser)

        args = _parse_arguments('Register a Cassandra cluster for repairs',
                                'spreaper register [<args>]',
                                arguments_for_register)
        reaper = self.init_reaper(args)
        print "# registering Cassandra cluster with seed host: {0}".format(args.seed_host)
        reaper.call_register(args.owner, args.seed_host)
        print "# registration succeeded"

    def repair(self):
        def arguments_for_repair(parser):
            parser.add_argument("--seed-host", default=None,
                                help="the seed host of the target Cassandra cluster")
            parser.add_argument("--cluster-name", default=None,
                                help="the name of the target Cassandra cluster")
            _triggering_arguments(parser)

        args = _parse_arguments('Trigger a repair on a Cassandra cluster',
                                'spreaper repair [<args>]',
                                arguments_for_repair)
        reaper = self.init_reaper(args)
        if args.cluster_name:
            print "# triggering a repair on Cassandra cluster "\
                  "with name: {0}".format(args.cluster_name)
            reply = reaper.call_register(args.owner, cluster_name=args.cluster_name,
                                         keyspace=args.keyspace, table=args.table,
                                         cause=args.cause, repair_immediately=True)
        else:
            print "# triggering a repair on Cassandra cluster "\
                  "with seed host: {0}".format(args.seed_host)
            reply = reaper.call_register(args.owner, seed_host=args.seed_host,
                                         keyspace=args.keyspace, table=args.table,
                                         cause=args.cause, repair_immediately=True)
        print "# repair triggering succeeded. reply:"
        print reply

    def status_cluster(self):
        def arguments_for_status_cluster(parser):
            parser.add_argument("cluster_name", help="the cluster name")
        args = _parse_arguments('Show status of a cluster, including the repairs for the cluster',
                                'spreaper status-cluster repair_run_id [<args>]',
                                arguments_for_status_cluster)
        reaper = self.init_reaper(args)
        print "# cluster '{0}':".format(args.cluster_name)
        cluster_data = reaper.call_status_cluster(args.cluster_name)
        print json.dumps(cluster_data, indent=2)

    def status_repair(self):
        def arguments_for_status_repair(parser):
            parser.add_argument("repair_run_id", help="the repair run id")
        args = _parse_arguments('Show status of a repair run',
                                'spreaper status-repair repair_run_id [<args>]',
                                arguments_for_status_repair)
        reaper = self.init_reaper(args)
        print "# repair run with id {0}".format(args.repair_run_id)
        repair_run = reaper.call_status_repair(args.repair_run_id)
        print json.dumps(repair_run, indent=2)


class ReaperCaller(object):
    '''Implements the functionality for calling the Reaper service.
    Keep the CLI specific stuff in ReaperCLI.'''
    def __init__(self, host_name, host_port, use_ssl):
        self.base_url = "{0}://{1}:{2}".format(use_ssl and 'https' or 'http',
                                               str(host_name), int(host_port))

    def _http_req(self, http_method, the_url, params=None):
        http_method = http_method.upper()
        if params is None:
            params = {}
        log.info("making HTTP %s to %s", http_method, the_url)
        if http_method == 'GET':
            r = requests.get(the_url, params=params)
        elif http_method == 'POST':
            r = requests.post(the_url, params=params)
        else:
            assert False, "invalid HTTP method: {0}".format(http_method)
        log.info("HTTP %s return code %s with content of length %s",
                 http_method, r.status_code, len(str(r.text)))
        r.raise_for_status()
        return r.text

    def call_list_clusters(self):
        the_url = urlparse.urljoin(self.base_url, "cluster")
        reply = self._http_req("GET", the_url)
        return json.loads(reply)

    def call_register(self, owner, seed_host=None, cluster_name=None, keyspace=None, table=None,
                      cause=None, repair_immediately=False):
        if not seed_host and not cluster_name:
            print "either seed-host or cluster-name required for registering cluster"
            exit(1)
        if cluster_name:
            params = {"clusterName": cluster_name}
        else:
            params = {"seedHost": seed_host}

        if not keyspace and not table:
            if repair_immediately:
                print "you cannot repair whole cluster, but must define table and keyspace name"
                exit(1)
            the_url = urlparse.urljoin(self.base_url, "cluster")
        elif not keyspace or not table:
            print "both 'keyspace' and 'table' (or neither) required for registering"
            exit(1)
        else:
            the_url = urlparse.urljoin(self.base_url, "table")
            params['keyspace'] = keyspace
            params['table'] = table
            params['owner'] = owner
            params['cause'] = cause and cause or DEFAULT_CAUSE
            if repair_immediately:
                params['startRepair'] = 'true'

        reply = self._http_req("POST", the_url, params=params)
        return json.loads(reply)

    def call_status_cluster(self, cluster_name):
        the_url = urlparse.urljoin(self.base_url, "cluster/{0}".format(cluster_name))
        reply = self._http_req("GET", the_url)
        return json.loads(reply)

    def call_status_repair(self, repair_run_id):
        the_url = urlparse.urljoin(self.base_url, "repair_run/{0}".format(repair_run_id))
        reply = self._http_req("GET", the_url)
        return json.loads(reply)

    def call_ping(self):
        the_url = urlparse.urljoin(self.base_url, "ping")
        return self._http_req("GET", the_url)


if __name__ == '__main__':
    ReaperCLI()
